#   delta: 0 a 4 Hz
#   theta: 5 a 7 Hz
#   alpha: 8 a 12 Hz
#   sigma: 13 a 15 Hz
#   beta: 16 a 30 Hz
#
# Parâmetros:
#   1. eeg_data - Matriz contendo os 3 sinais eeg
#
# Retorno:
#   Lista com os sub sinais representando os sinais filtrados nas 5 faixas de
# frequência
#   d$XX$YY | XX = {s1, s2, s3}, YY = {delta, theta, alpha, sigma, beta}
#
#   d$s1$delta[,1] <- t
#   d$s1$delta[,2] <- sinal filtrado (0 a 4 Hz)
#
#   d$s1$theta[,1] <- t
#   d$s1$theta[,2] <- sinal filtrado (5 a 7 Hz)
#
# Exemplo:
#   sleep1 <- separate_sleep_eeg_band(d1)
#   sleep2 <- separate_sleep_eeg_band(d2)
#   sleep3 <- separate_sleep_eeg_band(d3)
#   sleep4 <- separate_sleep_eeg_band(d4)
#   sleep5 <- separate_sleep_eeg_band(d5)
#   sleep6 <- separate_sleep_eeg_band(d6)
#   sleep7 <- separate_sleep_eeg_band(d7)
#   sleep8 <- separate_sleep_eeg_band(d8)
##################################################################################
separate_sleep_eeg_band <- function(eeg_data){
require(astrochron)
separated_eeg <- NULL
separated_eeg$s1$delta <- as.matrix(bandpass(eeg_data[,c(1,2)],
fhigh = 4,
genplot = FALSE, win = 2))
separated_eeg$s2$delta <- as.matrix(bandpass(eeg_data[,c(1,3)],
fhigh = 4,
genplot = FALSE, win = 2))
separated_eeg$s3$delta <- as.matrix(bandpass(eeg_data[,c(1,4)],
fhigh = 4,
genplot = FALSE, win = 2))
separated_eeg$s1$theta <- as.matrix(bandpass(eeg_data[,c(1,2)],
flow = 5, fhigh = 7,
genplot = FALSE, win = 2))
separated_eeg$s2$theta <- as.matrix(bandpass(eeg_data[,c(1,3)],
flow = 5, fhigh = 7,
genplot = FALSE, win = 2))
separated_eeg$s3$theta <- as.matrix(bandpass(eeg_data[,c(1,4)],
flow = 5, fhigh = 7,
genplot = FALSE, win = 2))
separated_eeg$s1$alpha <- as.matrix(bandpass(eeg_data[,c(1,2)],
flow = 8, fhigh = 12,
genplot = FALSE, win = 2))
separated_eeg$s2$alpha <- as.matrix(bandpass(eeg_data[,c(1,3)],
flow = 8, fhigh = 12,
genplot = FALSE, win = 2))
separated_eeg$s3$alpha <- as.matrix(bandpass(eeg_data[,c(1,4)],
flow = 8, fhigh = 12,
genplot = FALSE, win = 2))
separated_eeg$s1$sigma <- as.matrix(bandpass(eeg_data[,c(1,2)],
flow = 13, fhigh = 15,
genplot = FALSE, win = 2))
separated_eeg$s2$sigma <- as.matrix(bandpass(eeg_data[,c(1,3)],
flow = 13, fhigh = 15,
genplot = FALSE, win = 2))
separated_eeg$s3$sigma <- as.matrix(bandpass(eeg_data[,c(1,4)],
flow = 13, fhigh = 15,
genplot = FALSE, win = 2))
separated_eeg$s1$beta <- as.matrix(bandpass(eeg_data[,c(1,2)],
flow = 16,
fhigh = 30, genplot = FALSE, win = 2))
separated_eeg$s2$beta <- as.matrix(bandpass(eeg_data[,c(1,3)],
flow = 16, fhigh = 30,
genplot = FALSE, win = 2))
separated_eeg$s3$beta <- as.matrix(bandpass(eeg_data[,c(1,4)],
flow = 16, fhigh = 30,
genplot = FALSE, win = 2))
return(separated_eeg)
}
filter_freq <- function(eeg_data, flow, fhigh){
require(astrochron)
separated_eeg <- eeg_data
separated_eeg[,c(1,2)] <- as.matrix(bandpass(eeg_data[,c(1,2)],
flow = flow, fhigh = fhigh,
genplot = FALSE, win = 2))
separated_eeg[,c(1,3)] <- as.matrix(bandpass(eeg_data[,c(1,3)],
flow = flow, fhigh = fhigh,
genplot = FALSE, win = 2))
separated_eeg[,c(1,4)] <- as.matrix(bandpass(eeg_data[,c(1,4)],
flow = flow, fhigh = fhigh,
genplot = FALSE, win = 2))
return(separated_eeg)
}
##################################################################################
# curve_length(x,y)
#
# Calcula o comprimento de uma curva representada em coordenadas cartesianas
#
# Parâmetros
#   1. x - Coordenadas x da curva
#   2. y - Coordenadas y da curva
#
# Retorna:
#   Valor numérico do comprimento
##################################################################################
curve_length <- function(x,y){
len = 0
for(i in 2:length(x)){
len = len + ((x[i]-x[i-1])^2+(y[i]-y[i-1])^2)^.5
}
return(len)
}
##################################################################################
# generate_features(d, freq, n_dwt, seg_len, stp, nrm, excerpt, id, chs, folder)
#
# Cria uma matriz de features de sinais EEG.
# Primeiro, decompõe o sinal usando a transformada discreta de wavelets em n
# níveis. Para cada intervalo de tempo x, extrai de cada sub sinal média da
# amplitude, desvio padrão, energia, simetria e comprimento de curva.
#
# Parâmetros:
#   1. d      - Matriz que contêm o sinal EEG. (generate_eeg_data)
#   2. freq   - Frequência de amostragem do sinal, em Hz
#   3. n_dwt  - Níveis da transformada de Wavelets
#   4. seg_len- Duração dos segmentos de tempo, em segundos
#   5. stp    - Incremento no desclocamento dos segmentos
#   6. nrm    - Deseja normalizar os dados?
#   7. excerpt- Número do paciente
#   8. id     - Sufixo do nome do arquivo a ser gerado (identificador)
#   9. chs    - Lista com os canais desejados
#   10. folder- Pasta em que os dados serão salvos
#
# Retorna:
#   Matriz de features.
#   Gera arquivo em disco: wav_all_exX.csv | X = {1,2,3,4,5,6,7,8}#
#   Colunas da tabela:
#     Sejam os sinais C, O, F,
#     os sub-sinais: {D1, D2, ..., DN},
#     e os segmentos de tempo: {seg1, seg2, ..., segM}
#
#     Tabela:
#       seg1: | média(D1_C) | SD(D1_C) | Enrg(D1_C) | CurvLen(D1_C) | Sim(D1_C) | ...
#             | média(DN_C) | ...  ... | Sim(DN_C)  | média(D1_O)   | ...
#       seg2: | média(D1) | SD(D1) | Enrg(D1) | CurvLen(D1) | Sim(D1) | média (D2) | ...
#       ...
#
# Exemplo:
#   freq = 256
#   n_dwt = 5
#   seg_len = 2
#
#   f1 <- generate_features(d1, freq, n_dwt, seg_len, TRUE, 1)
#   f2 <- generate_features(d2, freq, n_dwt, seg_len, TRUE, 2)
#   f3 <- generate_features(d3, freq, n_dwt, seg_len, TRUE, 3)
#   f4 <- generate_features(d4, freq, n_dwt, seg_len, TRUE, 4)
#   f5 <- generate_features(d5, freq, n_dwt, seg_len, TRUE, 5)
#   f6 <- generate_features(d6, freq, n_dwt, seg_len, TRUE, 6)
#   f7 <- generate_features(d7, freq, n_dwt, seg_len, TRUE, 7)
#   f8 <- generate_features(d8, freq, n_dwt, seg_len, TRUE, 8)
##################################################################################
generate_features <- function(d, freq, n_dwt, seg_len, stp, nrm, excerpt, id, chs, folder){
require(psd)
require(waveslim)
require(e1071)
require(ppls)
require(DescTools)
natt = 5
n_seg = as.integer(length(d[,1])/(stp*freq))
inc1 = as.integer(stp*freq)
inc2 = as.integer(seg_len*freq)
chs = chs-1
n_chs = length(chs)
wd = 0
dt <- matrix(nrow = n_seg, ncol = (n_dwt)*natt*n_chs + 2)
for(k in 0:(n_chs-1)){
for(i in 0:(n_seg-2)){
if(i/50 == as.integer(i/50)){
print(paste('Sinal', (chs[k+1]), '->', round(i*100/n_seg,1), '%', sep = ' '))
}
#print(i)
#print(c(i, length(d[,1]), inc1, inc2, n_seg))
#print((i*inc1+1):(i*inc1+inc2))
wd <- dwt(d[(i*inc1+1):(i*inc1+inc2),2+chs[k+1]], n.levels = n_dwt)
for(j in 1:n_dwt){
media = mean(wd[[j]])
desvP = sd(wd[[j]])
max_t = max(d[(i*inc1+1):(i*inc1+inc2),1])
min_t = min(d[(i*inc1+1):(i*inc1+inc2),1])
if(j == length(wd)){
spct <- pspectrum(wd[[j]], niter = 20,
x.frqsamp = freq/(2^(length(wd) - 1)), verbose = FALSE)
curvlen = curve_length(seq(min_t,max_t, ((2^j)-1)/freq), wd[[j]])
}else{
spct <- pspectrum(wd[[j]], niter = 20,
x.frqsamp = freq/2^j, verbose = FALSE)
curvlen = curve_length(seq(min_t,max_t, (2^j)/freq), wd[[j]])
}
energ = mean(spct$spec)
skewn = skewness(wd[[j]])
#rms = sum((wd[[j]]^2)/length(wd[[j]]))^.5
#kurt = kurtosis(wd[[j]])
#FFT_OSC <- fft(wd[[j]])
#magn <- Mod(FFT_OSC)
#phase <- Arg(FFT_OSC)[1:(length(FFT_OSC)/2)]
#x.axis <- 1:length(magn)
#teste <- matrix(nrow = length(x.axis), ncol = 2)
#teste[,1]<-x.axis/1800
#teste[,2]<-magn
#plot(teste,type="l", xlab = "Frequência (Hz)", ylab = "Magnitude", main = 'Componentes em frequência do sinal original')
#mfreq = teste[which(teste[,2] == max(magn)),][1]
#mmagn = max(magn)
#unif = ks.test(wd[[j]], 'punif')$statistic[[1]]
#entr = Entropy(wd[[j]], base = 10)
#plot(teste,type="l", xlab = "Frequência (Hz)", ylab = "Magnitude")
# densA = density(magn)
# pmagn = densA$y[which(abs(densA$x-mmagn)==min(abs(densA$x-mmagn)))]
# fmagn = densA$x[which(densA$y==max(densA$y))]
# pffreq = max(densA$y)
# ffreq = teste[which(abs(teste[,2]-fmagn)==min(abs(teste[,2]-fmagn)))][1]
# plot(densA)
# dens<-density(magn, from=11, to=16, adjust = 0.5)
# integrate(approxfun(dens), lower=0, upper=16)
dt[(i+1),(j-1)*natt + 1 + k*5*natt] <- media
dt[(i+1),(j-1)*natt + 2 + k*5*natt] <- desvP
dt[(i+1),(j-1)*natt + 3 + k*5*natt] <- energ
dt[(i+1),(j-1)*natt + 4 + k*5*natt] <- curvlen
dt[(i+1),(j-1)*natt + 5 + k*5*natt] <- skewn
#dt[(i+1),(j-1)*natt + 6 + k*5*natt] <- rms
#dt[(i+1),(j-1)*natt + 7 + k*5*natt] <- kurt
#dt[(i+1),(j-1)*natt + 8 + k*5*natt] <- mfreq
#dt[(i+1),(j-1)*natt + 9 + k*5*natt] <- mmagn
#dt[(i+1),(j-1)*natt + 10 + k*5*natt] <- unif
#dt[(i+1),(j-1)*natt + 11 + k*5*natt] <- entr
# dt[(i+1),(j-1)*natt + 9 + k*5*natt] <- ffreq
# dt[(i+1),(j-1)*natt + 10 + k*5*natt] <- pffreq
# View(dt)
# scan()
}
if(sum(d[(i*inc1+1):(i*inc1+inc2),length(d[1,])-1]) > 0){
dt[(i+1),(n_dwt)*natt*n_chs + 1] <- 1
}else{
dt[(i+1),(n_dwt)*natt*n_chs + 1] <- 0
}
if(sum(d[(i*inc1+1):(i*inc1+inc2),length(d[1,])]) > 0){
dt[(i+1),(n_dwt)*natt*n_chs + 2] <- 1
}else{
dt[(i+1),(n_dwt)*natt*n_chs + 2] <- 0
}
}
}
# View(dt)
#scan()
if(nrm){
for(i in 1:(n_dwt*natt*n_chs)){
dt[,i] <- normalize.vector(dt[,i])
#dt[,i] = (dt[,i]-min(dt[,i]))/(max(dt[,i])-min(dt[,i]))
}
}
#View(dt)
#scan()
write.table(dt, file = paste(PATH_OUT_FEATURES, folder, "wav_ex", excerpt,"_", id, ".csv", sep = ""), quote = FALSE, sep = ',', row.names = FALSE, col.names = FALSE)
return(dt)
}
segment_signals <- function(d, freq, seg_len, stp, nrm, excerpt, id, folder, op){
require(psd)
require(waveslim)
require(e1071)
require(ppls)
n_seg = as.integer(length(d[,1])/(stp*freq))
inc1 = as.integer(stp*freq)
inc2 = as.integer(seg_len*freq)
if(op == 'psd'){
n_col = freq*seg_len/2
}
if(op == 'sig'){
n_col = freq*seg_len
}
dt <- matrix(nrow = n_seg, ncol = n_col + 2)
for(i in 0:(n_seg-1)){
wd <- d[(i*inc1+1):(i*inc1+inc2),2]
if(op == 'psd'){
spct <- pspectrum(wd, niter = 20, x.frqsamp = freq, verbose = FALSE)
dt[i+1,1:n_col] <- log10(spct$spec)
}else{
dt[i+1,1:n_col] <- wd
}
if(sum(d[(i*inc1+1):(i*inc1+inc2),length(d[1,])-1]) > 0){
dt[(i+1), n_col + 1] <- 1
}else{
dt[(i+1), n_col + 1] <- 0
}
if(sum(d[(i*inc1+1):(i*inc1+inc2),length(d[1,])]) > 0){
dt[(i+1), n_col + 2] <- 1
}else{
dt[(i+1), n_col + 2] <- 0
}
}
if(nrm){
for(i in 1:900){
v = dt[i,1:n_col]
m = min(v)
M = max(v)
dt[i,1:n_col] = (v-m)/(M-m)
}
}
write.table(dt, file = paste(folder, op, "_ex", excerpt,"_", id, ".csv", sep = ""), quote = FALSE, sep = ',', row.names = FALSE, col.names = FALSE)
}
plot_wavelets <- function(d, n_dwt){
require(waveslim)
wd <- dwt(d[,2], n.levels = n_dwt)
xl = c(0,max(d[,1]))
yl = c(-300,300)
plot((0:(length(d[,2])-1))/256,d[,2], type = 'l', xlab = 'Tempo (s)', ylab = 'Sinal EEG', main = 'Canal C3-A1 - Paciente 1', xlim = xl, ylim = yl)
plot((0:(length(wd$d1)-1))*2/256,wd$d1, type = 'l', xlab = 'Tempo (s)', ylab = 'D1', main = '', xlim = xl, ylim = yl)
plot((0:(length(wd$d2)-1))*4/256,wd$d2, type = 'l', xlab = 'Tempo (s)', ylab = 'D2', main = '', xlim = xl, ylim = yl)
plot((0:(length(wd$d3)-1))*8/256,wd$d3, type = 'l', xlab = 'Tempo (s)', ylab = 'D3', main = '', xlim = xl, ylim = yl)
plot((0:(length(wd$d4)-1))*16/256,wd$d4, type = 'l', xlab = 'Tempo (s)', ylab = 'D4', main = '', xlim = xl, ylim = yl)
plot((0:(length(wd$d5)-1))*32/256,wd$d5, type = 'l', xlab = 'Tempo (s)', ylab = 'D5', main = '', xlim = xl, ylim = yl)
}
##################################################################################
# plot_PCA(f, features, limit, title)
#
# Cria gŕaficos mostrando a variância e a porcentagem de variância de cada
# componente principal.
#
# Parâmetros:
#   1. f        - Tabela com as features
#   2. features - Vetor com os índices das colunas desejadas
#   3. limit    - Valor (0 a 1) que indica a porcentagem de variância desejada
#   4. title    - Subtítulo para o gráfico
#
# Retorna:
#   Gráfico em tela
#   Número de componentes que satisfazem o limite.
#
# Exemplo:
#   n_comp <- plot_PCA(f, c(1:75), .95, "Paciente 1")
#
##################################################################################
plot_PCA <- function(f, features, limit, title){
args_counter <- matrix(nrow = 75, ncol = 1)
args_counter[,1] <- 0
for(i in 1:75){
args_counter[i,1] <- paste('ARG', i-1, sep = '')
}
f <- data.frame(f)
colnames(f)<-args_counter
prin_comp <- prcomp(f[,features], scale. = T, center = T)
#biplot(prin_comp, scale = 0)
std_dev <- prin_comp$sdev
pr_var <- std_dev^2
prop_varex <- pr_var/sum(pr_var)
par(mfrow = c(1,2), oma = c(0,0,1,0))
plot(prop_varex, xlab = "Principal Component",
ylab = "Proportion of Variance Explained",
type = "b", pch = 19)
plot(cumsum(prop_varex), xlab = "Principal Component",
ylab = "Cumulative Proportion of Variance Explained",
type = "b", pch = 19)
abline(h = limit, col = 'red', lty = 2, lwd = 2)
n_pca = which(cumsum(prop_varex) >= limit)
abline(v = min(n_pca), col = 'blue', lwd = 2)
text(75, min(cumsum(prop_varex)+.05),
paste('Components for ', limit*100, '% \n of Variance: ',
min(n_pca), sep = ''),
pos = 2)
mtext(paste('Análise da Componente Principal\n', title, sep = ''), outer = TRUE, cex = 1.2,side = 3, line = -2)
return(min(n_pca))
}
##################################################################################
# data_PCA(f, features, n_comp, excerpt)
#
# Gera um arquivo csv com as n_comp componentes principais desejadas das features
# contidas na tabela f.
#
# Parâmetros:
#   1. f        - Tabela com as features
#   2. features - Vetor com os índices das colunas desejadas
#   3. n_comp   - Número de componentes desejadas
#   4. excerpt  - Número do paciente
#
# Retorna:
#   Grava em disco o arquivo csv
#
# Exemplo:
#   data_PCA(f1, c(1:75), n_comp, "Paciente 1")
#
##################################################################################
data_PCA <- function(f, features, n_comp, excerpt, id){
temp = as.data.frame(prin_comp$x[,1:n_comp])
temp[paste("PC",(n_comp+1),sep = "")] <- f1[,76]
write.table(temp, file = paste("pca1_ex", excerpt,"_", id, ".csv", sep = ""), quote = FALSE, sep = ',', row.names = FALSE, col.names = FALSE)
}
##################################################################################
generate_eeg_data_all_excerpts <- function(freq_out, scorer){
d <- NULL
d$d1 <- generate_eeg_data(1,1,100,freq_out,scorer)
d$d2 <- generate_eeg_data(2,0,200,freq_out,scorer)
d$d3 <- generate_eeg_data(3,1,50,freq_out,scorer)
d$d4 <- generate_eeg_data(4,0,200,freq_out,scorer)
d$d5 <- generate_eeg_data(5,0,200,freq_out,scorer)
d$d6 <- generate_eeg_data(6,0,200,freq_out,scorer)
d$d7 <- generate_eeg_data(7,0,200,freq_out,scorer)
d$d8 <- generate_eeg_data(8,0,200,freq_out,scorer)
return(d)
}
generate_eeg_data_all_excerpts_filter <- function(freq_out, scorer){
d <- NULL
d$d1 <- generate_eeg_data(1,1,100,freq_out,scorer)
d$d1 <- filter_freq(d$d1,11,16)
d$d2 <- generate_eeg_data(2,0,200,freq_out,scorer)
d$d2 <- filter_freq(d$d2,11,16)
d$d3 <- generate_eeg_data(3,1,50,freq_out,scorer)
d$d3 <- filter_freq(d$d3,11,16)
d$d4 <- generate_eeg_data(4,0,200,freq_out,scorer)
d$d4 <- filter_freq(d$d4,11,16)
d$d5 <- generate_eeg_data(5,0,200,freq_out,scorer)
d$d5 <- filter_freq(d$d5,11,16)
d$d6 <- generate_eeg_data(6,0,200,freq_out,scorer)
d$d6 <- filter_freq(d$d6,11,16)
d$d7 <- generate_eeg_data(7,0,200,freq_out,scorer)
d$d7 <- filter_freq(d$d7,11,16)
d$d8 <- generate_eeg_data(8,0,200,freq_out,scorer)
d$d8 <- filter_freq(d$d8,11,16)
return(d)
}
generate_features_all_excerpts <- function(d, freq, n_dwt, seg_len, stp, id, chs, nrm, folder){
f <- NULL
f$f1 <- generate_features(d$d1, freq, n_dwt, seg_len, stp, nrm, 1, id, chs, folder)
f$f2 <- generate_features(d$d2, freq, n_dwt, seg_len, stp, nrm, 2, id, chs, folder)
f$f3 <- generate_features(d$d3, freq, n_dwt, seg_len, stp, nrm, 3, id, chs, folder)
f$f4 <- generate_features(d$d4, freq, n_dwt, seg_len, stp, nrm, 4, id, chs, folder)
f$f5 <- generate_features(d$d5, freq, n_dwt, seg_len, stp, nrm, 5, id, chs, folder)
f$f6 <- generate_features(d$d6, freq, n_dwt, seg_len, stp, nrm, 6, id, chs, folder)
f$f7 <- generate_features(d$d7, freq, n_dwt, seg_len, stp, nrm, 7, id, chs, folder)
f$f8 <- generate_features(d$d8, freq, n_dwt, seg_len, stp, nrm, 8, id, chs, folder)
return(f)
}
plot_PCA_all_excerpts <- function(f, comps, limit, name){
n_comp1 <- plot_PCA(f$f1, comps, limit, paste(name, "1", sep = " "))
print("Next?")
scan()
n_comp2 <- plot_PCA(f$f2, comps, limit, paste(name, "2", sep = " "))
print("Next?")
scan()
n_comp3 <- plot_PCA(f$f3, comps, limit, paste(name, "3", sep = " "))
print("Next?")
scan()
n_comp4 <- plot_PCA(f$f4, comps, limit, paste(name, "4", sep = " "))
print("Next?")
scan()
n_comp5 <- plot_PCA(f$f5, comps, limit, paste(name, "5", sep = " "))
print("Next?")
scan()
n_comp6 <- plot_PCA(f$f6, comps, limit, paste(name, "6", sep = " "))
print("Next?")
scan()
n_comp7 <- plot_PCA(f$f7, comps, limit, paste(name, "7", sep = " "))
print("Next?")
scan()
n_comp8 <- plot_PCA(f$f8, comps, limit, paste(name, "8", sep = " "))
n_comps <- c(n_comp1,n_comp2,n_comp3,n_comp4,n_comp5,n_comp6,n_comp7,n_comp8)
return(n_comps)
}
data_PCA_all_excerpts <- function(f, comps, n_comp, id){
data_PCA(f$f1, comps, n_comp, 1, id)
data_PCA(f$f2, comps, n_comp, 2, id)
data_PCA(f$f3, comps, n_comp, 3, id)
data_PCA(f$f4, comps, n_comp, 4, id)
data_PCA(f$f5, comps, n_comp, 5, id)
data_PCA(f$f6, comps, n_comp, 6, id)
data_PCA(f$f7, comps, n_comp, 7, id)
data_PCA(f$f8, comps, n_comp, 8, id)
}
create_database <- function(){
freq_out = 256
n_dwt = 5
seg_len = 0.5
stp = 0.25
comps = c(1:75)
limit = .95
name = "Paciente"
scorer = 0
chs = c(1,2,3)
folder = 'data_75/'
id = "spindles"
nrm = F
# d <- generate_eeg_data_all_excerpts_filter(freq_out, scorer)
d <- generate_eeg_data_all_excerpts(freq_out, scorer)
f <- generate_features_all_excerpts(d, freq_out, n_dwt, seg_len, stp, id, chs, nrm, folder)
# n_comps <- plot_PCA_all_excerpts(f, comps, limit, name)
# n = max(n_comps)
# data_PCA_all_excerpts(f, comps, n, id)
}
##################################################################################
predict_to_time <- function(pred){
vec <- matrix(nrow = sum(pred), ncol = 1)
count = 1
for(i in 1:length(pred)){
if(pred[i]){
vec[count,1] = i*2
count = count + 1
}
}
ret <- NULL
ret$`[Spindles/C3-A1]` <- vec[,1]
ret$`[Spindles/CZ-A1]` <- vec[,1]
ret$Dur <- rep(2,length(vec))
return(ret)
}
create_database()
